# 1. 컬렉션 프레임워크(collections framework)
## 1-1 컬렉션 프레임워크란 ?
- 컬렉션(collection)
  - 여러 객체(데이터)를 모아 놓은 것을 의미


- 프레임워크(framework)
  - 표준화, 정형화된 체계적인 프로그래밍 방식


- 컬렉션 프레임워크(collections framework)
  - 컬렉션(다수의 객체)을 다루기 위한 표준화된 프로그래밍 방식
  - 컬렉션을 쉽고 편리하게 다룰 수 있는 다양한 클래스를 제공
  - java.util패키지에 포함. JDK1.2부터 제공


- 컬렉션 클래스(collection class)
  - 다수의 데이터를 저장할 수 있는 클래스(예, Vector, ArrayList, HashSet ) 

<br>

## 1-2 컬렉션 프레임워크의 핵심 인터페이스 
<img width="813" alt="스크린샷 2023-03-31 오후 10 24 15" src="https://user-images.githubusercontent.com/121492344/229132196-1bef5e8e-47b3-4120-8ef2-1a04ac0b2af1.png">
컬렉션 프레임워크의 모든 컬렉션 클래스들은 List, Set, Map 중의 하나를 구현하고 있다. 

<br>

## 1-3 Collection 인터페이스의 메서드
<img width="866" alt="스크린샷 2023-03-31 오후 10 26 27" src="https://user-images.githubusercontent.com/121492344/229132692-97d99484-2226-43f1-a4a6-b57c44fc8ea9.png">
반환 타입이 boolean인 메서드들은 작업을 성공하거나 사실이면 true를, 아니면 false를 반환한다. 

<br>

## 1-4 List 인터페이스의 메서드 - 순서 O, 중복 O
<img width="714" alt="스크린샷 2023-03-31 오후 10 28 53" src="https://user-images.githubusercontent.com/121492344/229133239-1539d260-6816-4067-8216-1781a980f34e.png">

<img width="787" alt="스크린샷 2023-03-31 오후 10 28 58" src="https://user-images.githubusercontent.com/121492344/229133256-dc4131f1-0247-4d76-95e6-2d833fd1199d.png">

<br>

<br>

## 1-5 Set 인터페이스의 메서드 - 순서 X, 중복 X
<img width="908" alt="스크린샷 2023-03-31 오후 10 31 42" src="https://user-images.githubusercontent.com/121492344/229133853-df19195c-dc5a-44f4-98fb-9a375b7f2370.png">

<br>

## 1-6 Map 인터페이스의 메서드 - 순서 X, 중복(키X, 값O)
<img width="884" alt="스크린샷 2023-03-31 오후 10 33 11" src="https://user-images.githubusercontent.com/121492344/229134191-5a688fa3-0a5d-4291-bfa1-ed1badc60dd2.png">

<br>

### Map.Entry 인터페이스
- Map인터페이스의 내부 인터페이스이다.
  <img width="517" alt="스크린샷 2023-03-31 오후 10 36 38" src="https://user-images.githubusercontent.com/121492344/229134982-abf3ba78-e615-498c-843a-0ac092d3ae4b.png">


<br>

## 2-1 ArrayList
- ArrayList는 기존의 Vector를 개선한 것으로 구현원리와 기능적으로 동일하다. Vector는 자체적으로 동기화처리가 되어 있으나 ArrayList는 그렇지 않다.
- List인터페이스를 구현하므로, 저장순서가 유지되고 중복을 허용한다.
- 데이터의 저장공간으로 배열을 사용한다.(배열기반)

## 2-2 ArrayList의 사용 예 

```java
import java.util.*;

public class ArrayListEx1 {
    public static void main(String[] args) {
        ArrayList list1 = new ArrayList(10);  // 크기가 10인 ArrayList를 생성.
        list1.add(new Integer(5));      // list1에 5를 추가.
        list1.add(new Integer(4));      // list1에 4를 추가.
        list1.add(new Integer(2));      // list1에 2를 추가.
        list1.add(new Integer(0));      // list1에 0를 추가.
        list1.add(new Integer(1));      // list1에 1를 추가.
        list1.add(new Integer(3));      // list1에 3를 추가.

        ArrayList list2 = new ArrayList(list1.subList(1,4));    // list1의 1~4의(1은 포함, 4는 미포함) 범위의 객체를 list2에 저장.
        print(list1,list2);

        Collections.sort(list1);        // list1과 list2를 오름차순정렬.
        Collections.sort(list2);
        print(list1, list2);

        System.out.println("list1.containsAll(list2):"
                                                + list1.containsAll(list2)); // list2의 객체들이 list1에 포함되어 있는가 ?

        list2.add("B");     // list2 맨 뒤에 "B"추가.
        list2.add("C");     // list2 맨 뒤에 "C"추가.    // list2:[0,2,4,B,C]
        list2.add(3, "A");  // index[3]자리에 "A"추가    list2:[0,2,4,A,B,C]
        print(list1, list2);

        list2.set(3, "AA");  // index[3]자리에 "AA"를 저장.  list2:[0,2,4,AA,B,C]
        print(list1, list2);

        // list1에서 list2와 겹치는 부분만 남기고 나머지는 삭제한다.
        System.out.println("list1.retainAll(list2):"     // [0,1,2,3,4,5] [0,2,4,AA,B,C] 에서 0,2,4가 겹치므로 
                                                + list1.retainAll(list2));   //0,2,4 빼고 나머지 삭제.

        print(list1, list2);

        //list2에서 list1에 포함된 객체들을 삭제한다.
        for(int i=list2.size()-1; i>=0; i--) {
            if(list1.contains(list2.get(i)))
                list2.remove(i);
        }
        print(list1, list2);
    }

    static void print(ArrayList list1, ArrayList list2) {
        System.out.println("list1:"+list1);
        System.out.println("list2:"+list2);
        System.out.println();
    }
}
```
```java
실행결과
        
list1:[5, 4, 2, 0, 1, 3]
list2:[4, 2, 0]

list1:[0, 1, 2, 3, 4, 5]
list2:[0, 2, 4]

list1.containsAll(list2):true
list1:[0, 1, 2, 3, 4, 5]
list2:[0, 2, 4, A, B, C]

list1:[0, 1, 2, 3, 4, 5]
list2:[0, 2, 4, AA, B, C]

list1.retainAll(list2):true
list1:[0, 2, 4]
list2:[0, 2, 4, AA, B, C]

list1:[0, 2, 4]
list2:[AA, B, C]
```

## 2-3 ArrayList에 저장된 객체의 삭제과정
<img width="773" alt="스크린샷 2023-04-02 오후 1 53 41" src="https://user-images.githubusercontent.com/121492344/229332095-61cb907d-4b37-4eca-8432-45ee99d3f4d0.png">

<img width="738" alt="스크린샷 2023-04-02 오후 1 53 46" src="https://user-images.githubusercontent.com/121492344/229332102-244ed5db-5b0b-4e93-90fd-0c3d4400c458.png">


## 2-4 Vector의 크기(size)와 용량(capacity)
<img width="909" alt="스크린샷 2023-04-02 오후 1 59 21" src="https://user-images.githubusercontent.com/121492344/229332294-61ccf99d-8045-430d-b0ec-f2ec35d5089a.png">


## 2-5 Java API 소스보기
Vector클래스와 같이 Java API에서 제공하는 기본 클래스의 실제 소스를 보고 싶다면, JDK를 설치한 디렉토리의 src.zip파일을 찾아가서 압축을 푼 다음, 
패키지별로 찾아 들어가면 원하는 클래스의 실제 소스를 볼 수 있다.
<img width="711" alt="스크린샷 2023-04-02 오후 2 01 49" src="https://user-images.githubusercontent.com/121492344/229332377-731d6700-5dde-4682-8867-c1fd217c3c92.png">

<br>

## 2-6 ArrayList의 장점과 단점
- 장점 : 배열은 구조가 간단하고 데이터를 읽는 데 걸리는 시간(접근시간, access time)이 짧다.
  <img width="522" alt="스크린샷 2023-04-02 오후 8 18 15" src="https://user-images.githubusercontent.com/121492344/229349491-111e9b54-ca23-41aa-aaa7-b4334b10505b.png">

- 단점 1 : 크기를 변경할 수 없다.
  - 크기를 변경해야 하는 경우 새로운 배열을 생ㅇ성 후 데이터를 복사해야함.
  - 크기 변경을 피하기 위해 충분히 큰 배열을 생성하면, 메모리가 낭비됨.
- 단점 2 : 비순차적인 데이터의 추가, 삭제에 시간이 많이 걸린다.
  - 데이터를 추가하거나 삭제하기 위해, 다른 데이터를 옮겨야 함.
  - 그러나 순차적인 데이터 추가(끝에 추가)와 삭제(끝부터 삭제)는 빠르다.


## 3-1 LinkedList - 배열의 단점을 보완
- 배열과 달리 링크드 리스트는 불연속적으로 존재하는 데이터를 연결(link)
  <img width="510" alt="스크린샷 2023-04-02 오후 8 25 54" src="https://user-images.githubusercontent.com/121492344/229349842-7608c5fd-d887-4fcd-8f25-69c3abcd9884.png">
링크드 리스트의 각 요소(node)들은 자신과 연결된 다음 요소에 대한 참조(주소값)와 데이터로 구성되어 있다.
```java
class Node {
    Node    next;   // 다음 요소의 주소를 저장
    Object  obj;    // 데이터를 저장
}
```

- 데이터의 삭제 : 단 한 번의 참조변경만으로 가능
  <img width="509" alt="스크린샷 2023-04-02 오후 8 28 34" src="https://user-images.githubusercontent.com/121492344/229349993-f29c2fab-10de-4266-b7d6-376a4fd8ab26.png">

- 데이터의 추가 : 한번의 Node객체생성과 두 번의 참조변경만으로 가능
  <img width="522" alt="스크린샷 2023-04-02 오후 8 29 04" src="https://user-images.githubusercontent.com/121492344/229349996-759f37e7-7f48-4d00-a037-5decbaa3a3a8.png">
- 



## 3-2 LinkedList - 이중 연결 리스트
- 링크드 리스트 - 연결리스트. 이동방향이 단방향이기 때문에 다음 요소에 대한 접근은 쉽지만 이전요소에 대한 접근은 어렵다.
  <img width="836" alt="스크린샷 2023-04-02 오후 8 56 18" src="https://user-images.githubusercontent.com/121492344/229351254-a2bce7d5-b3f1-4e1d-a9b0-ea0df2579a25.png">

- 더블리 링크드 리스트 - 이중 연결리스트, 접근성 향상
<img width="841" alt="스크린샷 2023-04-02 오후 8 56 22" src="https://user-images.githubusercontent.com/121492344/229351256-f466baef-b346-480e-9451-7f267b730518.png">

- 더블리 써큘러 링크드 리스트 - 이중 원형 연결리스 
<img width="666" alt="스크린샷 2023-04-02 오후 8 56 26" src="https://user-images.githubusercontent.com/121492344/229351258-42d380ea-f3ca-4d06-bbaf-9af25ec4d652.png">

<br>

## 3-3 ArrayList vs LinkedList 성능 비교
1. 순차적으로 데이터를 추가/삭제 - ArrayList가 빠름
2. 비순차적으로 데이터를 추가/삭제 - LinkedList가 빠름
3. 접근 시간(access time) - ArrayList가 빠

```java
    인덱스가 n인 데이터의 주소 = 배열의 주소 + n * 데이터 타입의 크기
```
<img width="699" alt="스크린샷 2023-04-03 오전 10 37 54" src="https://user-images.githubusercontent.com/121492344/229392930-582e8069-365a-48d3-9c84-9cfe11d198b1.png">

<br>

## 4-1 스택(Stack)과 큐(Queue)
- 스택(Stack) : LIFO구조. 마지막에 저장된 것을 제일 먼저 꺼내게 된다. 
  - 수식 계산, 수식괄호검사, undo/redo, 뒤로/앞으로(웹브라우저)

- 큐(Queue) : FIFO구조. 제일 먼저 저장한 것을 제일 먼저 꺼내게 된다.
  - 최근 사용문서, 인쇄작업대기목록, 버퍼(buffer)

<img width="804" alt="스크린샷 2023-04-03 오전 10 48 33" src="https://user-images.githubusercontent.com/121492344/229393721-665a7308-daec-4d59-b53c-c7af27bf7e3f.png">

```java
import java.util.*;

public class StackQueueEx {
    public static void main(String[] args) {
        Stack st = new Stack();
        Queue q = new LinkedList();    // Queue인터페이스의 구현체인 LinkedList를 사용

        st.push("0");
        st.push("1");
        st.push("2");

        q.offer("0");
        q.offer("1");
        q.offer("2");

        System.out.println("= Stack =");
        while(!st.empty()) { // st가 비어있을 때까지
            System.out.println(st.pop());    // Stack의 맨 위에 저장된 객체를 꺼낸다.
        }

        System.out.println("= Queue =");
        while(!q.isEmpty()) { // q가 비어있을 때까지
            System.out.println(q.poll());    // q에서 객체를 꺼내서 반환. 
        }
    }
}
```
```java
= Stack =
2
1
0
= Queue =
0
1
2
```

자바에서는 스택을 Stack클래스로 구현하여 제공하고 있지만 큐는 Queue인터페이스로만 정의해 놓았을 뿐 별도의 클래스를 제공하고 있지 않다. 
대신 Queue인터페이스를 구현한 클래스들이 있어서 이 들 중 하나를 선택해서 사용하면 된다. 


<br>

## 알아두면 좋다 ! - 인터페이스를 구현한 클래스 찾기
<img width="725" alt="스크린샷 2023-04-03 오전 10 55 09" src="https://user-images.githubusercontent.com/121492344/229394335-6da13d6d-c53b-4c76-8836-116266378cca.png">

JAVA API문서를 참고해보자.

<br>

## 4-2 Queue의 변형 - Deque, PriorityQueue, BlockingQueue
- 덱(Deque) : Stack과 Queue의 결합. 양 끝에서 저장(offer)과 삭제(poll) 가능 (구현클래스 : ArrayDeque, LinkedList)
<img width="370" alt="스크린샷 2023-04-03 오전 11 52 39" src="https://user-images.githubusercontent.com/121492344/229400788-0095999d-10d2-4c5a-927b-3f62f6b4ea2e.png">

- 우선순위 큐(PriorityQueue) : 우선순위가 높은 것부터 꺼냄(null 저장불가). 입력[3,1,5,2,4] -> 출력[1,2,3,4,5]

- 블락킹 큐(BlockingQueue) : 비어 있을 때 꺼내기와, 가득 차 있을 때 넣기를 지정된 시간동안 지연시킴(block) - 멀티쓰레드

<br>

## 5-1 Iterator, ListIterator, Enumeration
- 컬렉션에 저장된 요소를 접근하는데 사용되는 인터페이스들이다.
- Enumeration은 Iterator의 구버전
- ListIterator는 Iterator의 접근성을 향상시킨 것이다. (단방향 -> 양방향)


<br>

## 5-2 Iterator
- 컬렉션에 저장된 요소들을 읽어오는 방법을 표준화한 것.
- 컬렉션에 저장된 각 요소에 접근하는 기능을 가진 Iterator인터페이스를 정의하고, Colltection인터페이스에는 'Iterator'를 반환하는 iterator()를 정의.
- iterator()는 Collection인터페이스에 정의된 메서드이므로 Collection인터페이스의 자손인 List와 Set에도 포함되어 있다.
- 컬렉션에 iterator()를 호출해서 Iterator를 구혆나 객체를 얻어서 사용한다.
 
<img width="553" alt="스크린샷 2023-04-03 오후 1 12 49" src="https://user-images.githubusercontent.com/121492344/229409752-82b3e900-b4ee-4f6f-9a0a-9fc7996cc35c.png">

```java
public interface Collection {
  ...
  public Iterator iterator();
  ...
}
```

```java
Collection c = new ArrayList();
                ⬆️⬆️⬆️⬆️⬆️⬆️⬆️ 다른 컬렉션으로 변경할 때는 이 부분만 고치면 된다.
Iterator it = c.iterator();

while(it.hasNext()) {     // 읽어 올 요소가 남아있는지 확인. 있으면 true, 없으면 false
    System.out.println(it.next());   // 다음 요소를 읽어온다.
        }
```

- Q. 참조변수의 타입을 ArrayList타입이 아니라 Collection타입으로 한 이유는 ?
  - A. Collection에 없고 ArrayList에만 있는 메서드를 사용하는게 아니라면, Collection타입의 참조변수로 선언하는 것이 좋다. 만일 Collection인터페이스를 구현한 다른 클래스, 예를 들어 LinkedList로 바꿔야 한다면 선언문 하나만 변경하면 나머지 코드는 검토하지 않아도 된다. 참조변수 타입이 Collection이므로 Collection에 정의되지 않은 메서드는 사용되지 ㅇ낳았을 것이 확실하기 때문이다. 그러나 참조변수 타입을 ArrayList로 했다면, 선언문 이후의 문장들을 검토해야 한다. Collection에 정의되지 않은 메서드를 호출했을 수 있기 때문이다.

<br>

- Map 인터페이스를 구현한 컬렉션 클래스는 키(key)와 값(value)을 쌍(pair)으로 저장하고 있기 때문에 iterator()를 직접 호출할 수 없고, 그 대신 keySet()이나 entrySet()과 같은 메서드를 통해서 키와 값을 각각 따로 Set의 형태로 얻어온 후에 다시 iterator()를 호출해야 Iterator를 얻을 수 있다.
```java
Map map = new HashMap();
        ...
Iterator it = map.entrySet().iterator();
// 위 문장은 아래의 두 문장을 하나로 합친 것이다.
Set eSet = map.entrySet();
Iterator it = eSet.iterator();
```
<img width="598" alt="스크린샷 2023-04-03 오후 1 23 48" src="https://user-images.githubusercontent.com/121492344/229411113-9c9accfa-ae59-4b5b-bbaf-9aa814a99956.png">

```java
import java.util.*;

public class IteratorEx1 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("1");
        list.add("2");
        list.add("3");
        list.add("4");
        list.add("5");

        Iterator it = list.iterator();

        while(it.hasNext()) {
            Object obj = it.next();
            System.out.println(obj);
        }
    }
}
```
```java
실행결과
1
2
3
4
5
```
List클래스들은 저장순서를 유지하기 때문에 Iterator를 이용해서 읽어 온 결과 역시 저장순서와 동일하지만 
Set클래스들은 각 요소간의 순서가 유지 되지 않기 때문에 Iterator를 이용해서 저장된 요소들을 읽어 와도 처음에 저장된 순서와 같지 않다.

<br>

## 5-3 ListIterator - Iterator의 기능을 확장(상속)
- Iterator의 접근성을 향상시킨 것이 ListIterator이다. (단방향 -> 양방향)
- listIterator()를 통해서 얻을 수 있다.
- ArrayList나 LinkedList와 같이 List인터페이스를 구현한 컬렉션에서만 사용할 수 있다.
  <img width="416" alt="스크린샷 2023-04-03 오후 3 05 19" src="https://user-images.githubusercontent.com/121492344/229424605-e453d1f2-acbf-451a-a00d-c464c38513f7.png">

```java
import java.util.*;

public class ListIteratorEx1 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();
        list.add("1");
        list.add("2");
        list.add("3");
        list.add("4");
        list.add("5");

        ListIterator it = list.listIterator();

        while(it.hasNext()) {
            System.out.println(it.next()); // 순방향으로 진행하면서 읽어온다.
        }
        System.out.println();

        while ((it.hasPrevious())) {
            System.out.println(it.previous()); // 역방향으로 진행하면서 읽어온다.
        }
        System.out.println();
    }
}
```
```java
실행결과
1
2
3
4
5

5
4
3
2
1
```


## 5-4 Enumeration - IIterator의 구버전
- Enumeration은 이전 버전으로 작성된 소스와의 호환을 위해서 남겨 두고 있을 뿐이므로 가능하면 Enumeration대신 Iterator를 사용하자.
<img width="553" alt="스크린샷 2023-04-03 오전 11 56 41" src="https://user-images.githubusercontent.com/121492344/229401242-e1651c01-aeae-43f1-a8df-665a3e88c198.png">

<br>

## 6-1 Arrays - 배열을 다루기 편리한 메서드(모두 static) 제공
1. 배열의 출력 - toString()

```java
static String toString(boolean[] a)
static String toString(byte[] a)
static String toString(char[] a)
static String toString(short[] a)
static String toString(int[] a)
static String toString(long[] a)
static String toString(float[] a)
static String toString(double[] a)
static String toString(Object[] a)
```

<br>


2. 다차원 배열의 비교와 출력 - deepEquals(), deepToString(), equals()
   
- toString()은 일차원 배열에만 사용할 수 있으므로, 다차원 배열에는 deepToString()을 사용해야 한다.
```java
int[] arr = {0, 1, 2, 3, 4};
int[][] arr2D = {{11,12}, {21,22}};
  
System.out.println(Arrays.toString(arr));  // [0,1,2,3,4]
System.out.println(Arrays.deepToString(arr2D));  // [[11,12], [21,22]]
```
- 다차원 배열의 비교에는 deepEquals()를 사용해야 한다.
```java
String[][] str2D  = new String[][]{{"aaa","bbb"}}, {"AAA","BBB"}};
String[][] str2D2 = new String[][]{{"aaa","bbb"}}, {"AAA","BBB"}};

System.out.println(Arrays.equals(str2D, str2D2));        //false
System.out.println(Arrays.deepEquals(str2D, str2D2));    //true
```

3. 배열의 복사 - copyOf(), copyOfRange()
- copyOf()는 배열 전체를, copyOfRange()는 배열의 일부를 복사해서 새로운 배열을 만들어 반환한다.
- copyOfRange()에 지정된 범위의 끝은 포함되지 않는다.
```java
int[] arr = {0,1,2,3,4};
int[] arr2 = Arrays.copyOf(arr, arr.length);  // arr2 = [0,1,2,3,4]
int[] arr3 = Arrays.copyOf(arr, 3);           // arr3 = [0,1,2]
int[] arr4 = Arrays.copyOf(arr, 7);           // arr4 = [0,1,2,3,4,0,0]

int[] arr5 = Arrays.copyOfRange(arr, 2, 4);   // arr5 = [2,3]
int[] arr6 = Arrays.copyOfRange(arr, 0, 7);   // arr6 = [0,1,2,3,4,0,0]
```

4. 배열 채우기 - fill(), setAll()
- fill()은 배열의 모든 요소를 지정된 값으로 채운다.
- setAll()은 배열을 채우는데 사용할 함수형 인터페이스를 매개변수로 받는다.
- 이 메서드를 호출할 때는 함수형 인터페이스를 구현한 객체를 매개변수로 지정하던가 아니면 람다식을 지정해야한다.

```java
int[] arr = new int[5];
Arrays.fill(arr, 9);      // arr = [9,9,9,9,9]
Arrays.setAll(arr, () -> (int)(Math.random()*5)+1);   // arr= [1,5,2,1,1]
```

5. 배열의 정렬과 검색 - sort(), binarySearch()
- sort()는 배열을 정렬할 때, binarySearch()는 배열에 저장된 요소를 검색할 때 사용한다.
- binarySearch()는 반드시 배열이 정렬된 상태이어야 올바른 결과를 얻는다.
```java
int[] arr = { 3, 2, 0, 1, 4};              // 정렬되지 않은 배열
int idx = Arrays.binarySearch(arr, 2);     // idx = -5  <- 잘못된 결과

Arrays.sort(arr);   // 배열 arr을 정렬한다.
System.out.println(Arrays.toString(arr));  // [0,1,2,3,4]
int idx = Arrays.binarySearch(arr, 2);     // idx = 2   <- 올바른 결과
```

6. 배열을 List로 변환 - asList(Object... a)
- asList()는 배열을 List에 담아서 반환한다.
- 매개변수의 타입이 가변인수라서 배열 생성없이 저장할 요소들만 나열하는 것도 가능하다.
```java
List list = Arrays.asList(new Integer[]{1,2,3,4,5});  // list = [1,2,3,4,5]
List list = Arrays.asList(1,2,3,4,5)                  // list = [1,2,3,4,5
```

- asList()가 반환한 List의 크기를 변경할 수 없기 때문에 크기를 변경할 수 있는 List가 필요하다면 다음과 같이 한다.
```java
List list = new ArrayList(Arrays.asList(1,2,3,4,5));
```

<br>

## 6-2 - Comparator와 Comparable
- 객체를 정렬하는데 필요한 메서드를 정의한 인터페이스이다.(정렬기준을 제공)
- Comparable을 구현한 클래스는 정렬이 가능하다는 것을 의미한다.

```java
    Comparable  :  기본 정렬기준을 구현하는데 사용
    Comparator  :  기본 정렬기준 외에 다른 기준으로 정렬하고자할 때 사용
```
```java
Comparator와 Comparable의 실제 소스

public interface Comparator {
    int compare(Object o1, Object o2);  // o1, o2 두 객체를 비교
    boolean equals(Object obj);  // equals를 오버라이딩하라는 뜻
}

public interface Comparable {
    public int compareTo(Object o);  // 주어진 객체(o)를 자신(this)과 비교 
}
```

- compare()와 compareTo()는 두 객체의 비교결과를 반환하도록 작성한다.(같으면 0, 오른쪽이 크면 음수(-), 오른쪽이 작으면 양수(+))
```java
public final class Integer extends Number implements Comparable {  // Compareble 인터페이스의 compareTo 메서드를 구현해야한다. 
  ...
  public int compareTo(Object o) {
      return compareTo((Integer)o);
  }
  
  public int compareTo(Integer anotherInteger) {  // Comparable인터페이스의 compareTo메서드 구현.
      int thisVal = this.value;
      int anotherVal = anotherInteger.value;
      
      // 비교하는 값이 크면 -1, 같으면 -, 작으면 1을 반환한다.
    return (thisVal<anotherVal ? -1 : (thisVal==anotherVal ? 0 : 1));
  }
  ...
}
```

```java
import java.util.*;

public class ComparatorEx {
    public static void main(String[] args) {
        String[] strArr = {"cat", "Dog", "lion", "tiger"};

        Arrays.sort(strArr);  // String의 Comparable구현에 의한 정렬
        // 정렬대상만 있는 이유는 String클래스가 Comparable인터페이스를 구현해서 compareTo라는 기본정렬메서드를 구현했기 때문.

        System.out.println("strArr=" + Arrays.toString(strArr));

        Arrays.sort(strArr,   String.CASE_INSENSITIVE_ORDER);  // 대소문자 구별안함
        //           ⬆️정렬대상             ⬆️정렬기준.
        System.out.println("strArr=" + Arrays.toString(strArr));

        Arrays.sort(strArr, new Descending());  // 역순 정렬
        System.out.println("strArr=" + Arrays.toString(strArr));
    }
}

    class Descending implements Comparator {  // Comparator인터페이스를 구현하여 새로운 정렬기준 생성
        public int compare(Object o1, Object o2) {
            if( o1 instanceof Comparable && o2 instanceof Comparable) {
                Comparable c1 = (Comparable)o1;
                Comparable c2 = (Comparable)o2;
                return c1.compareTo(c2) * -1;  // -1을 곱해서 기본 정렬방식의 역으로 변경한다.
                                            // 또는 c2.compareTo(c1)와 같이 순서를 바꿔도 된다.
            }
        return -1;
    }
}
```
```java
실행결과 
strArr=[Dog, cat, lion, tiger]
strArr=[cat, Dog, lion, tiger]
strArr=[tiger, lion, cat, Dog]
```

<br>


## 7-1 HashSet과 TreeSet - 순서X, 중복X
<img width="261" alt="스크린샷 2023-04-03 오후 9 11 55" src="https://user-images.githubusercontent.com/121492344/229505432-94e867fd-085e-4568-b3d2-d187781e9181.png">

- HashSet
  - Set인터페이스를 구현한 대표적인 컬렉션 클래스
  - 순서를 유지하려면, LinkedHashSet클래스를 사용하면 된다.
  - HashSet에 새로운 요소를 추가할 때 add메서드나 addAll메서드를 사용하는데, 만일 HashSet에 이미 저장되어 있는 요소와 중복된 요소를 추가하고자 한다면 이 메서드는 false를 반환함으로써 중복된 요소이기 때문에 추가에 실패했다는 것을 알린다.
  - 컬렉션 내의 중복 요소들을 쉽게 제거할 수 있다.
```java
import java.util.*;

public class HashSetEx1 {
    public static void main(String[] args) {
        Object[] objArr = {"1", new Integer(1), "2","2","3","4","4","4"};
        Set set = new HashSet();

        for(int i=0; i< objArr.length; i++) {
            set.add(objArr[i]);    // HashSet에 objArr의 요소들을 저장한다.
        }
        // HashSet에 저장된 요소들을 출력한다.
        System.out.println(set);
    }
}
```
```java
실행결과
[1, 1, 2, 3, 4]
// '1'이 두 번 출력된 이유는 하나는 String인스턴스이고 다른 하나는 Integer인스턴스로 서로 다른 객체이므로 중복으로 간주하지 않기 때문이다.
```

- TreeSet
  - 범위 검색과 정렬에 유리한 컬렉션 클래스
  - HashSet보다 데이터 추가, 삭제에 시간이 더 걸림.

























