# 1. 상속
## 1-1 상속의 정의와 장점

상속이란, 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다.   
상속을 통해 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있다.  

- 상속을 구현하는 법    
```java
class 자손클래스 extends 조상클래스 {
    //...
}
```
```java
class Child extends Panret {
    // Parent클래스를 상속받는 Child클래스 작성.
}
```
이 두 클래스는 서로 `상속 관계`에 있다고 하며, 상속해주는 클래스를 `조상 클래스`, 상속 받는 클래스를 `자손 클래스`라 한다.

```java
조상 클래스 : 부모클래스, 상위클래스, 기반클래스
자손 클래스 : 자식클래스, 하위클래스, 파생된클래스 
```
<img width="632" alt="스크린샷 2023-03-13 오후 8 10 30" src="https://user-images.githubusercontent.com/121492344/227763133-f3411251-6cd9-433f-ba4c-a0fd6c3b3545.png">

자손 클래스는 조상 클래스의 모든 멤버를 상속받기 때문에 Child클래스는 Parent클래스의 멤버들을 포함한다고 할 수 있다.  

만일 Parent클래스에 age라는 정수형 변수를 멤버변수로 추가하면, Child클래스는 자동적으로 age라는 멤버변수가 추가된 것과 같은 효과를 받는다. 

```java
class Parent {
    int age;
}

class Child extends Parent {  }
```

<img width="483" alt="스크린샷 2023-03-13 오후 8 16 48" src="https://user-images.githubusercontent.com/121492344/227763404-e3ea7144-1f57-40e5-ac5d-9f5f0303e624.png">


<br>

>생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.   
> 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

>자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.


<br>

## 1-2 클래스간의 관계 - 포함관계 
클래스 간의 `포함`관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다. 

원을 표현하기 위한 Circle클래스를 작성하고 
```java
class Circle {
    int x;      // 원점의 x좌표
    int y;      // 원점의 y좌표
    int r;      // 반지름
}
```
그리고 좌표성의 한 점을 다루기 위한 Point클래스를 작성
```java
class Point {
    int x;     // x좌표
    int y;     // y좌표
}
```

여기서 Point클래스를 재사용해서 Circle클래스에 포함시킬 수 있다.
```java
class Circle {
    Point c = new Point();  // 원점
    int r;
}
```

## 1-3 클래스간의 관계 결정하기

- 상속, 포함 어떨 때 사용해야하나 ?
  -  '~은 이다(is a)'와 '~은 ~을 가지고 있다(has a)'를 넣어서 보면 클래스 간의 관계가 명확해 진다.

```java
원은 점이다 - Circle is a Point.
원은 점을 가지고 있다. - Circle has a Point.  // 더 자연스러운 문장
```

```java
상속관계 '~은 ~이다'
포함관계'~은 ~을 가지고 있다' 
```

<br>

## 1-4 단일 상속

자바에서는 오직 단일 상속만을 허용한다.   
단일 상속은 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다는 점에서 다중상속보다 유리하다.
```java
class Tv {
    boolean power;
    int channel;

    void power() {power=!power;}
    void channelUp() {++channel;}
    void channelDown() {--channel;}
}

class VCR {
    boolean power;
    int counter = 0;
    void power() {power=!power;}
    void play() { /* 내용생략 */}
    void stop() { /* 내용생략 */}
    void rew() { /* 내용생략 */}
    void ff() { /* 내용생략 */}
}

class TVCR  extends Tv{
    VCR vcr = new VCR();  // VCR클래스를 포함시켜서 사용한다.

    void play() {
        vcr.play();
    }

    void stop() {
        vcr.stop();
    }

    void rew() {
        vcr.rew();
    }

    void ff() {
        vcr.ff();
    }
}
```

비중이 높은 클래스는 상속으로, 나머지는 포함관계로 한다. 

<br>

## 1-5. Object클래스 - 모든 클래스의 조상

- Object클래스는 모든 클래스 상속계층도의 최상위에 있는 조상클래스이다.   
- 조상이 없는 클래스는 자동적으로 Object클래스를 상속받게 된다.
- 모든 클래스는 Object클래스에 정의된 11개의 메서드를 상속받는다. toString(), equals(OBject obj), 등등...

<img width="535" alt="스크린샷 2023-03-20 오후 8 39 20" src="https://user-images.githubusercontent.com/121492344/227763442-f803225a-4abd-4b74-bb76-2ef1c7e00f8e.png">



<br>

## 2. 오버라이딩(overriding)

## 2-1 오버라이딩이란 ?

조상클래스로부터 `상속받은 메서드의 내용`을 상속받는 클래스에 맞게 `변경하는 것`을 오버라이딩이라고 한다. 

```java
class Point {
    int x;
    int y;
    
    String getLocation() {
        return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;
    String getLocation() {      // 오버라이딩. 
         return "x :" + x + ", y :" + y + ", z :" + z;
    }
}
```

<br>

## 2-2 오버라이딩의 조건

1. 선언부가 같아야 한다.(이름, 매개변수, 리턴타임)
2. 접근제어자를 좁은 범위로 변경할 수 없다.   <br>
조상의 메서드가 protected라면, 범위가 같거나 넓은 protected나 public으로만 변경할 수 있다.
3. 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다. 


## 2-3 오버로딩 vs 오버라이딩

```java
오버로딩  -  기존에 없는 새로운 메서드를 정의하는 것(new)
오버라이딩 -  상속받은 메서드의 내용을 변경하는 것
```
```java
class Parent {
    void parentMethod() {}
}

class Child extends Parent {
    void parentMethod() {}        // 오버라이딩
    void parentMethod(int i) {}   // 오버로딩 
  
    void childMethod() {}         
    void childMethod(int i){}    // 오버로딩
    void childMethod() {}        // 에러 ! 중복정의임. 
}
```

<br>

## 2-4 super - 참조변수

```java
this - 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어있음.
       모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재

super - this와 같음. 조상의 멤버와 자신의 멤버를 구별하는 데 사용. 
```
```java
class Point {
    int x;
    int y;
    
    String getLocation() {
        return "x :" + x + ", y :" + y;
    }
}

class Point3D extends Point {
    int z;
    String getLocation() {      // 오버라이딩.
        // return "x :" + x + ", y :" + y + ", z :" + z;
           return super.getLocation() + ", z :" + z;  // 조상의 메서드 호출. 
    }
}
```

<br>

## 2-5 super() - 조상의 생성자

- 자손클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 합쳐진 하나의 인스턴스가 생성된다. 
- 조상의 멤버들도 초기화되어야 하기 때문에 자손의 생성자의 첫 문장에서 조상의 생성자를 호출해야 한다. 

```java
Object클래스를 제외한 모든 클래스의 생성자 첫 줄에는 생성자(같은 클래스의 다른 생성자 또는 조상의 생성자)를 호출해야한다.
그렇지 않으면 컴파일러가 자동적으로 'super();'를 생성자의 첫 줄에 삽입한다. 
```


<img width="474" alt="스크린샷 2023-03-20 오후 9 43 42" src="https://user-images.githubusercontent.com/121492344/227763474-04fb388c-444c-4623-a879-edd71c243b07.png">

<br>


<img width="738" alt="스크린샷 2023-03-20 오후 9 48 33" src="https://user-images.githubusercontent.com/121492344/227763476-fa81ee4b-dd37-4b32-a3dd-94dae118ddb9.png">

<br>

## 3. package와 import

## 3-1 패키지(package)
- 서로 관련된 클래스와 인터페이스의 묶음.
- 클래스가 물리적으로 클래스파일(*.class)인 것처럼, 패키지는 물리적으로 폴더이다. 패키지는 서브패키지를 가질 수 있으며, '.'으로 구분한다.
- 클래스의 실제 이름(full name)은 패키지명이 포함된 것이다. (String 클래스의 full name은 java.lang.String)
- rt.jar는 Java API의 기본 클래스들을 압축한 파일이다.

<br>

## 3-2 패키지의 선언
- 패키지는 소스파일에 첫 번째 문장(주석 제외)으로 단 한번 선언된다.
- 하나의 소스파일에 둘 이상의 클래스가 포함된 경우, 모두 같은 패키지에 속하게 된다.(하나의 소스파일에 단 하나의 public클래스만 허용된다.)
- 모든 클래스는 하나의 패키지에 속하며, 패키지가 선언되지 않은 클래스는 자동적으로 이름없는(default) 패키지에 속하게 된다.

## 3-3 import문
- 사용할 클래스가 속한 패키지를 지정하는데 사용한다.
- import문을 사용하면 클래스를 사용할 때 패키지명을 생략할 수 있다.
<img width="639" alt="스크린샷 2023-03-26 오후 5 39 12" src="https://user-images.githubusercontent.com/121492344/227764793-7c302dcb-dc32-4d2a-ad45-38c36dd410db.png">

- java.lang패키지의 클래스에는 import하지 않아도 사용할 수 있다. String, Object, System, Thread ...등등 

## 3-4 import문의 선언
- import문은 패키지문과 클래스선언의 사이에 선언한다.

```java
일반적인 소스파일(*.java)의 구성은 다음의 순서로 되어 있다.
1. package문
2. import문
3. 클래스 선언
```

<br>

- import문은 선언하는 방법은 다음과 같다.
```java
import 패키지명.클래스명;
     또는
import 패키지명.*;
```

<br>

- import문은 컴파일 시에 처리되므로 프로그램의 성능에 아무런 영향을 미치지 않는다.
  <img width="559" alt="스크린샷 2023-03-26 오후 5 43 16" src="https://user-images.githubusercontent.com/121492344/227764968-0d3de43b-fc07-4868-a35e-b3fa01a8488d.png">

<br>

- 이름이 같은 클래스가 속한 두 패키지를 import할 때는 클래스 앞에 패키지명을 붙여줘야 한다.
```java
import java.sql.*;   // java.sql.Date
import java.util.*;  // java.util.Date
```

<br>

## 4. 제어자(modifier)
## 4-1 제어자란 ?
- 클래스, 변수, 메서드의 선언부에 사용되어 부가적인 의미를 부여한다.
- 제어자는 크게 접근 제어자와 그 외의 제어자로 나뉜다.
- 하나의 대상에 여러 개의 제어자를 조합해서 사용할 수 있으나, 접근제어자는 단 하나만 사용할 수 있다. 
```java
접근 제어자 - public, protected, default, private
그     외 - static, final, abstract, native, transient, synchronized, volatile, strictfp
```

## 4-2 static - 클래스의, 공통적인
- static이 사용될 수 있는 곳 - 멤버변수, 메서드, 초기화 블럭
<img width="684" alt="스크린샷 2023-03-26 오후 6 24 51" src="https://user-images.githubusercontent.com/121492344/227766715-8cd9c95d-fd1b-4fe4-a654-63459a6bb02d.png">
```java
class StaticTest {
    static int width = 200;     // 클래스 변수
    static int height = 120;    // 클래스 변수
    
    static{ // 클래스 초기화 블럭
        // static 변수의 복잡한 초기화 수행
    }
    
    static int max(int a, int b) {  // 클래스 메서드
        return a > b ? a : b;
    }
}
```

## 4-3 final - 마지막의, 변경될 수 없는
- final이 사용될 수 있는 곳 - 클래스, 메서드, 멤버변수, 지역변수
  <img width="683" alt="스크린샷 2023-03-26 오후 6 29 53" src="https://user-images.githubusercontent.com/121492344/227766960-7c508f25-1e9e-4f70-993f-c296db9875c1.png">

```java
final class FinalTest {
    final int MAX_SIZE = 10;   // 멤버변수
  
    final void getMaxSize() {
        final int LV = MAX_SIZE;   // 지역변수
        return MAX_SIZE;
    }
}

class Child extends FinalTest {
    void getMaxSize() {}  // 에러. 오버라이딩 불가
}
```

## 4-4 생성자를 이용한 final 멤버변수 초기화
- final이 붙은 변수는 상수이므로 보통은 선언과 초기화를 동시에 하지만, 인스턴스마다 고정값을 갖는 인스턴스 변수의 경우 생성자에서 초기화된다. (카드의 무늬와 숫자는 한번 결정되면 바뀌지 않아야하는 경우)

```java
class Card {
    final int NUMBER;
    final String KIND;
    static int width = 100;
    static int height = 250;
    
    Card(String kind, int num) {
        KIND = kind;
        NUMBER - num;
    }
    
    Card() {
        this("HEART", 1);
    }
    
    public String toString() {
        return "" + KIND +" "+ NUMBER;
    }
}
```

<br>

## 4-5 abstract - 추상의, 미완성의
- abstract가 사용될 수 있는 곳 - 클래스, 메서드 
<img width="671" alt="스크린샷 2023-03-26 오후 6 36 51" src="https://user-images.githubusercontent.com/121492344/227767315-21def31c-804d-46ed-a221-49f240cb8e37.png">

```java
abstract class AbstarctTest { // 추상클래스
    abstract void move();     // 추상메서드
}
```

<br>

## 4-6 접근 제어자(access modifier)
- 멤버 또는 클래스에 사용되어, 외부로부터 접근을 제한한다.
- 접근 제어자가 사용될 수 있는 곳 - 클랫, 멤버변수, 메서드, 생성자
```java
private - 같은 클래스 내에서만 접근이 가능
default - 같은 패키지 내에서만 접근이 가능
protected - 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서 접근이 가능
public - 접근 제한이 없음.
```

<img width="425" alt="스크린샷 2023-03-26 오후 6 42 30" src="https://user-images.githubusercontent.com/121492344/227767562-1ac8d84f-2adf-4c7f-ba97-b687e6143603.png">

<br>

## 4-7 접근 제어자를 이용한 캡슐화
접근 제어자를 사용하는 이유
- 외부로부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는, 부분을 감추기 위해서

<img width="683" alt="스크린샷 2023-03-26 오후 6 49 09" src="https://user-images.githubusercontent.com/121492344/227767871-1af87724-5616-4302-8517-668033227070.png">

<br>

## 4-8 생성자의 접근 제어가
- 일반적으로 생성자의 접근 제어자는 클래스의 접근 제어자와 일치한다.
- 생성자에 접근 제어자를 사용함으로써 인스턴스의 생성을 제한할 수 있다. 
```java
final class Singleton {
    private static Singleton s = new Singleton();  // getInstance()에서 사용될 수 있도록 인스턴스가 미리 생성되어야 하므로 static이어야 한다. 
    
    private Singleton() { // 생성자
        //...
    }
    
    public static Singleton getInstance() {
        if(s==null) {
            s = new Singleton();
        }
        return s;
    }
}
```

## 4-9 제어자의 조합
<img width="453" alt="스크린샷 2023-03-26 오후 6 55 55" src="https://user-images.githubusercontent.com/121492344/227768222-fe84cfce-3ce4-4b16-9877-bfef72367ccc.png">

1. 메서드에 static과 abstract를 함께 사용할 수 없다.
   - static메서드는 몸통(구현부)이 있는 메서드에만 사용할 수 있기 때문이다.
2. 클래스에 abstract와 final을 동시에 사용할 수 없다.
   - 클래스에 사용되는 final은 클래스를 확장할 수 없다는 의미이고, abstract는 상속을 통해서 완성되어야 한다는 의미이므로 서로 모순되기 때문이다.
3. abstract메서드의 접근제어자가 private일 수 없다.
   - abstract메서드는 자손클래스에서 구현해주어야 하는데 접근 제어자가 private이면, 자손클래스에서 접근할 수 없기 때문이다.
4. 메서드에 private과 final을 같이 사용할 필요는 없다.
   - 접근 제어자가 private인 메서드는 오버라이딩될 수 없기 때문이다. 이 둘 중 하나만 사용해도 의미가 충분하다. 


































