# 1.제네릭스, 열거형, 애너테이션

## 1-1 제네릭스(Generics)란 ?
- 컴파일시 타입을 체크해 주는 기능(compile-time type check) - JDK1.5
- 객체의 타입 안정성을 높이고 형변환의 번거로움을 줄여줌 (하나의 컬렉션에는 대부분 한 종류의 객체만 저장)
```java
  제네릭스의 장점
    1. 타입 안정성을 제공한다.
    2. 타입체크와 형변환을 생략할 수 있으므로 코드가 간결해 진다.
```

<br>

## 1-2 제네릭 클래스의 선언
- 클래스를 작성할 때, Object타입 대신 T와 같은 타입변수를 사용
```java
class Box {
    Object item;
    
    void setItem(Object item) { this.item = item;}
    Object getItem() { return item;}
}
```
⬇️   ⬇️
```java
class Box<T> {  // 제네릭 타입 T를 선언
    T item;
    
    void setItem(T item) { this.item = item;}
    T getItem { return item;}
}
```

<br>

- 참조변수, 생성자에 T대신 실제 타입을 지정하면 형변환 생략가능

```java
Box<String> b = new Box<String>();   // 타입 T대신, 실제 타입을 지정
b.setItem(new Object());             // 에러. String이외의 타입은 지정불가
b.setItem("ABC");                    // OK. String타입이므로 가능
String item = (String) b.getItem     // 형변환이 필요없음.
```

- 위 코드에서 타입 T대신에 String타입을 지정해줬으므로, 지네릭 클래스 Box\<T\>는 다음과 같이 정의된 것과 같다.
```java
class Box { 
    String item;
    
    void setItem(String item) { this.item = item;}
    String getItem() { return item;}
}
```
<br>

## 1-3 제네릭스 용어
```java
  Box<T>  : 지네릭 클래스. 'T의 Box'또는 'T Box'라고 읽는다.
  T       : 타입 변수 또는 타입 매개변수(T는 타입 문자)
  Box     : 원시 타입(raw type)
```
<img width="377" alt="스크린샷 2023-04-04 오후 3 21 20" src="https://user-images.githubusercontent.com/121492344/229705225-637f0124-ed85-4642-a3f2-6c1fe355e4a7.png">

예를 들어, Box\<String\>과 Box\<Integer\>는 지네릭 클래스 Box\<T\>에 서로 다른 타입을 대입하여 호출한 것일 뿐, 
이 둘이 별개의 클래스를 의미하는 것은 아니다. add(3,5)와 add(2,4)가 서로 다른 메서드를 호출하는 것이 아닌 것과 같다.   
 컴파일 후에 Box\<String\>과 Box\<Integer\>는 이들의 '원시 타입'인 Box로 바뀐다. 즉, 지네릭 타입이 제거된다.



## 1-4 제네릭스의 제약사항
- static멤버에는 타입 변수 T를 사용할 수 없다.
```java
class Box<T> {
    static T item;   // 에러
    static int compare(T t1, T t2) {...} // 에러
        ...
}
```

<br>

- 제네릭 타입의 배열 T[]를 생성하는 것은 허용되지 않는다.
```java
class Box<T> {
    T[] itemArr;   // OK. T타입의 배열을 위한 참조변수
        ...
    T[] toArray() {
        T[] tmpArr = new T[itemArr.length];  // 에러. 제네릭 배열 생성불가
        ...
        return tmpArr;
    }
}
```


## 1-5 제네릭 클래스의 객체 생성과 사용
- 제네릭 클래스 Box<T>의 선언

```java
class Box<T> {
    ArrayList<T> list = new ArrayList<T>();
    
    void add(T item)           { list.add(item);        }
    T get(int i)               { return list.get(i);    }
    ArrayList<T> getList()     { return list;           }
    int size()                 { return list.size();    }
    public String toString()   { return list.toString();}
}
```

<br>

- Box<T>의 객체 생성. 참조변수와 생성자에 대입된 타입이 일치해야 함.
```java
Box<Apple> appleBox = new Box<Apple>();   // OK
Box<Apple> appleBox = new Box<Grape>();   // 에러. 대입된 타입이 다르다.
Box<Fruit> appleBox = new Box<Apple>();   // 에러. 대입된 타입이 다르다.
// Apple이 Fruit의 자손이라고 가정해도 에러이다.
```

<br>

- 두 제네릭 클래스가 상속관계이고, 대입된 타입이 일치하는 것은 OK
```java
Box<Apple> appleBox = new FruitBox<Apple>();   // OK. 다형성
Box<Apple> appleBox = new Box<>();            // OK. JDK1.7부터 가능
```

<br>

- 대입된 타입과 다른 타입의 객체는 추가할 수 없다.
```java
Box<Apple> appleBox = new Box<Apple>();
appleBox.add(new Apple());  // OK.
appleBox.add(new Grape());  // 에러. Box<Apple>에는 Apple객체만 추가가능
```

- 그러나 타입 T가 'Fruit'인 경우, 'void add(Fruit item)'가 되므로 Fruit의 자손들은 이 메서드의 매개변수가 될 수 있다. Apple이 Fruit의 자손이라고 가정하였다.
```java
Box<Fruit> fruitBox = new Box<Fruit>();
fruitBox.add(new Fruit());    // OK.
fruitBox.add(new Apple());    // OK.  void add(Fruit item)
```

예제
```java
import java.util.ArrayList;

class Fruit                { public String toString() { return "Fruit";}}
class Apple extends Fruit  { public String toString() { return "Apple";}}
class Grape extends Fruit  { public String toString() { return "Grape";}}
class Toy                  { public String toString() { return "Toy";  }}


public class FruitBox1 {
    public static void main(String[] args) {
        Box<Fruit> fruitBox = new Box<Fruit>();
        Box<Apple> appleBox = new Box<Apple>();
        Box<Toy>   toyBox   = new Box<Toy>();
     // Box<Grape> grapeBox = new Box<Apple>();   // 에러. 타입 불일치

        fruitBox.add(new Fruit());
        fruitBox.add(new Apple());

        appleBox.add(new Apple());
        appleBox.add(new Apple());
      //appleBox.add(new Toy());  // 에러. Box<Apple>에는 Apple만 담을 수 있음.

        toyBox.add(new Toy());
      //toyBox.add(new Apple());  // 에러. Box<Toy>에는 Apple을 담을 수 없음

        System.out.println("fruitBox : " +fruitBox);
        System.out.println("appleBox : " +appleBox);
        System.out.println("toyBox : " +toyBox);

    }
}

class Box<T> {
    ArrayList<T> list = new ArrayList<T>();
    void add(T item)  { list.add(item);    }
    T get(int i)      { return list.get(i);}
    int size()        { return list.size();}
    public String toString() { return list.toString();}
}
```
```java
실행 결과
fruitBox : [Fruit, Apple]
appleBox : [Apple, Apple]
toyBox : [Toy]
```

<br>

## 1-6 제한된 제네릭 클래스
- 제네릭 타입에 'extends'를 사용하면, 특정 타입의 자손들만 대입할 수 있게 제한할 수 있다.
```java
class FruitBox<T extends Fruit> {  // Fruit의 자손만 타입으로 지정가능
    ArrayList<T> list = new ArrayList<T>();
    void add(T item)    {list.add(item);}
    ...
}
```

<br>

- add()의 매개변수 타입 T도 Fruit와 그 자손 타입이 될 수 있다.
```java
FruitBox<Fruit> fruitBox = new FruitBox<Fruit>();
fruitBox.add(new Apple());   // OK. Apple이 Fruit의 자손
fruitBox.add(new Grape());   // OK. Grape가 Fruit의 자손
```
다형성에서 조상타입의 참조변수로 자손타입 객체를 가리킬 수 있는 것처럼, 매개변수화된 타입의 자손 타입도 가능한 것이다. 타입 매개변수 T에 Object를 대입하면, 모든 종류의 객체를 저장할 수 있게 된다.

<br>

- 인터페이스의 경우에도 'implements'가 아닌, 'extends'를 사용
```java
interface Eatable {}
class FruitBox <T extends Eatable> {...}
class FruitBox <T extends Fruit & Eatable> {...} // 클래스 Fruit의 자손이면서 Eatable인터페이스를 구현
```

```java
import java.util.ArrayList;

class Fruit2 implements Eatable {  // Eatable 인터페이스를 구현함.
    public String toString() {return "Fruit";}
}
class Apple2 extends Fruit2 { public String toString() { return "Apple";}}
class Grape2 extends Fruit2 { public String toString() { return "Grape";}}
class Toy2                  { public String toString() { return "Toy"  ;}}
interface Eatable {}


class FruitBoxEx2 {
    public static void main(String[] args) {
        FruitBox<Fruit2> fruitBox = new FruitBox<Fruit2>();
        FruitBox<Apple2> appleBox = new FruitBox<Apple2>();
        FruitBox<Grape2> grapeBox = new FruitBox<Grape2>();
      //FruitBox<Grape2> grapeBox = new FruitBox<Apple2>(); // 에러. 타입 불일치
      //FruitBox<Toy2>   ToyBox   = new FruitBox<Toy2>();   // 에러. 클래스 Toy2는 Fruit2의 자손도, 인터페이스 Eatable을 구현하지도 않았음.

        fruitBox.add(new Fruit2());
        fruitBox.add(new Apple2());
        fruitBox.add(new Grape2());

        appleBox.add(new Apple2());
      //appleBox.add(new Grape2());   // 에러. Grape는 Apple의 자손이 아님.

        grapeBox.add(new Grape2());

        System.out.println("fruitBox-"+fruitBox);
        System.out.println("appleBox-"+appleBox);
        System.out.println("grapeBox-"+grapeBox);
    }
}

class FruitBox<T extends Fruit2 & Eatable> extends Box2<T> {}
// FruitBox에는 Fruit2의 자손이면서 Eatable을 구현한 클래스만 타입 매개변수 T에 대입될 수 있음.

class Box2<T> {
    ArrayList<T> list = new ArrayList<T>();
    void add(T item)  { list.add(item); }
    T get(int i)      { return list.get(i); }
    int size()        { return list.size(); }
    public String toString() { return list.toString();}
}
```
```java
실행결과
fruitBox-[Fruit, Apple, Grape]
appleBox-[Apple]
grapeBox-[Grape]
```

<br>

## 1-7 와일드 카드 '?'
- 지네릭 타입에 와일드 카드를 쓰면, 여러 타입을 대입가능
- 단, 와일드 카드에는 <? extends T & E>와 같이 '&'를 사용불가

```java
   <? extends T> : 와일드 카드의 상한 제한. T와 그 자손들만 가능
   <? super T>   : 와일드 카드의 하한 제한. T와 그 조상들만 가능
   <?>           : 제한 없음. 모든 타입이 가능. <? extends Object>와 동일
```

```java
import java.util.ArrayList;

class Fruit3                { public String toString() { return "Fruit";}}
class Apple3 extends Fruit3 { public String toString() { return "Apple";}}
class Grape3 extends Fruit3 { public String toString() { return "Grape";}}

class Juice {
    String name;

    Juice(String name)       { this.name = name + "Juice";}
    public String toString() { return name;}
}

class Juicer {
    static Juice makeJuice(FruitBox3<? extends Fruit3> box) {
        String tmp = "";

        for(Fruit3 f : box.getList())
            tmp += f + " ";
        return new Juice(tmp);
    }
}

public class FruitBoxEx3 {
    public static void main(String[] args) {
        FruitBox3<Fruit3> fruitBox = new FruitBox3<Fruit3>();
        FruitBox3<Apple3> appleBox = new FruitBox3<Apple3>();

        fruitBox.add(new Apple3());
        fruitBox.add(new Grape3());
        appleBox.add(new Apple3());
        appleBox.add(new Apple3());

        System.out.println(Juicer.makeJuice(fruitBox));
        System.out.println(Juicer.makeJuice(appleBox));

    }
}

class FruitBox3<T extends Fruit3> extends Box3<T> {}

class Box3<T> {
    ArrayList<T> list = new ArrayList<T>();
    void add(T item) { list.add(item);      }
    T get(int i)     { return list.get(i);  }
    ArrayList<T> getList() { return list;   }
    int size()       { return list.size();  }
    public String toString() { return list.toString();}
}
```
```java
실행결과 
Apple Grape Juice
Apple Apple Juice
```


<br>

## 1-8












